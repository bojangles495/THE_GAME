import spyral
import random
import math

WIDTH = 1200
HEIGHT = 900
BG_COLOR = (0,0,0)
WHITE = (255, 255, 255)
SIZE = (WIDTH, HEIGHT)
LIST_OF_BRICKS = []
NUMBER_OF_MISSES = [0]
class Ball(spyral.Sprite):
    def __init__(self, scene):
        super(Ball, self).__init__(scene)
        self.image = spyral.Image(size=(20, 20))
        self.image.draw_circle(WHITE, (10, 10), 10)
        
        spyral.event.register("pong_score", self._reset)
        spyral.event.register("director.update", self.update)
        self._reset()
        
    def _reset(self):
        theta = random.random()*2*math.pi
        while ((theta > math.pi/4 and theta < 3*math.pi/4) or
               (theta > 5*math.pi/4 and theta < 7*math.pi/4)):
            theta = random.random()*2*math.pi
        r = 700
        
        self.vel_x = r * math.cos(theta)
        self.vel_y = r * math.sin(theta)
        self.anchor = 'center'
        self.pos = (WIDTH/2, HEIGHT/2)
                
    def update(self, delta):
        self.x += delta * self.vel_x
        self.y += delta * self.vel_y
        r = self.rect
        if r.top < 0:
            r.top = 0
            self.vel_y = -self.vel_y
        if r.bottom > HEIGHT:
	    NUMBER_OF_MISSES.append(NUMBER_OF_MISSES[0] + 1)
	    del NUMBER_OF_MISSES[0]
            spyral.event.handle("pong_score", spyral.Event(side='bottom'))
        
        if r.left < 0:
            r.left = 0
	    self.vel_x = -self.vel_x
        if r.right > WIDTH:
            r.right = WIDTH
	    self.vel_x = -self.vel_x
            
    def collide_paddle(self, paddle):
        if self.collide_sprite(paddle):
            self.vel_y = -self.vel_y
    def collide_brick(self, brick):
	if self.collide_sprite(brick):
	   self.vel_y = -self.vel_y
	   return True
	else:
	   return False

class Brick(spyral.Sprite):
	def __init__(self, scene, loc_x, loc_y):
		spyral.Sprite.__init__(self, scene)
		self.image = spyral.Image(size=(90,20)).fill((255, 255, 255))
		self.x = loc_x
		self.y = loc_y
	def changeSize(self):
		self.image = spyral.Image(size=(0,0)).fill((255,255,255))
		self.x = 0
		self.y = HEIGHT
	
class Paddle(spyral.Sprite):
    def __init__(self, scene, side):
        spyral.Sprite.__init__(self, scene)
        self.image = spyral.Image(size=(200, 20)).fill((255, 255, 255))
	self.anchor = 'midbottom'
	self.x = WIDTH / 2
	self.y = HEIGHT - 20
	self.side = side
	self.moving = False
	left = 'a'
	right = 'd'
	spyral.event.register("input.keyboard.down."+left, self.move_left)
	spyral.event.register("input.keyboard.down."+right, self.move_right)
	spyral.event.register("input.keyboard.up."+left, self.stop_move)
	spyral.event.register("input.keyboard.up."+right, self.stop_move)
	spyral.event.register("director.update", self.update)
	spyral.event.register("pong_score", self._reset)
        
    def move_left(self):
        self.moving = 'left'
    def move_right(self):
        self.moving = 'right'
    def stop_move(self):
        self.moving = False
    def _reset(self):
	self.x = WIDTH / 2
        self.y = HEIGHT - 20
        
    def update(self, delta):
        paddle_velocity = 800
        
        if self.moving == 'left':
            self.x -= paddle_velocity * delta
        elif self.moving == 'right':
            self.x += paddle_velocity * delta
                
        r = self.rect
        if r.left < 0:
            r.left = 0
        if r.right > WIDTH:
            r.right = WIDTH
            
        #self.pos == getattr(r, self.anchor)

class TicTacToe(spyral.Scene):
    def __init__(self, *args, **kwargs):
        global manager
        spyral.Scene.__init__(self, SIZE)
        self.background = spyral.Image(size=SIZE).fill(BG_COLOR)
        
        self.ball = Ball(self)
	self.bottom_paddle = Paddle(self, 'bottom')
	array_row = [0,100,200,300,400,500,600,700,800,900,1000,1100]
	array_column = [0,30,60,90,120,150,180,210,240,270,300]
	for column_element in array_column:
		for row_element in array_row:
			LIST_OF_BRICKS.append(Brick(self,row_element,column_element))
	
        spyral.event.register("system.quit", spyral.director.pop)
        spyral.event.register("director.update", self.update)
        spyral.event.register("input.keyboard.down.q", spyral.director.pop)
	
        
    def update(self, delta):
	number_of_blocks_captured = 0
        self.ball.collide_paddle(self.bottom_paddle)
	for brick in LIST_OF_BRICKS:
		if self.ball.collide_brick(brick) == True:
			brick.changeSize()
		if NUMBER_OF_MISSES[0] == 3:
			num_Bricks = len(LIST_OF_BRICKS) - 1
			for x in range(0,num_Bricks):
				del LIST_OF_BRICKS[0]
			array_row = [0,100,200,300,400,500,600,700,800,900,1000,1100]
			array_column = [0,30,60,90,120,150,180,210,240,270,300]
			for column_element in array_column:
				for row_element in array_row:
					LIST_OF_BRICKS.append(Brick(self,row_element,column_element))
			NUMBER_OF_MISSES.append(0)
			del NUMBER_OF_MISSES[0]
			self.ball._reset()
		if brick.y == HEIGHT:
			number_of_blocks_captured = number_of_blocks_captured + 1

	if number_of_blocks_captured == len(LIST_OF_BRICKS):
		num_Bricks = len(LIST_OF_BRICKS) - 1
		for x in range(0,num_Bricks):
			del LIST_OF_BRICKS[0]
		array_row = [0,100,200,300,400,500,600,700,800,900,1000,1100]
		array_column = [0,30,60,90,120,150,180,210,240,270,300]
		for column_element in array_column:
			for row_element in array_row:
				LIST_OF_BRICKS.append(Brick(self,row_element,column_element))
		NUMBER_OF_MISSES.append(0)
		del NUMBER_OF_MISSES[0]
		self.ball._reset()
		
